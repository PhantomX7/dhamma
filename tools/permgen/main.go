package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// PermissionModule represents a module's permissions
type PermissionModule struct {
	Name        string
	Key         string
	Permissions []PermissionField
}

// PermissionField represents a single permission field
type PermissionField struct {
	Name        string
	Value       string
	Description string // Can be extracted from comments
	Group       string // Optional grouping for related permissions
}

func main() {
	modulesDir := "../../modules"
	outputFile := "../../constants/permissions/generated_permissions.go"

	modules, err := scanModules(modulesDir)
	if err != nil {
		fmt.Printf("Error scanning modules: %v\n", err)
		os.Exit(1)
	}

	err = generatePermissions(modules, outputFile)
	if err != nil {
		fmt.Printf("Error generating permissions: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Permissions generated successfully!")
}

// scanModules scans all modules for permission definitions
func scanModules(modulesDir string) ([]PermissionModule, error) {
	var modules []PermissionModule

	// Walk through module directories
	err := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Look for module.go files
		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			// Parse the Go file
			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
			if err != nil {
				return nil
			}

			// Look for permission struct and var
			var module PermissionModule
			ast.Inspect(node, func(n ast.Node) bool {
				// Find the package name
				if file, ok := n.(*ast.File); ok {
					module.Name = file.Name.Name
				}

				// Find permission struct type
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if typeSpec.Name.Name == "permission" {
						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							for _, field := range structType.Fields.List {
								if len(field.Names) > 0 {
									perm := PermissionField{
										Name: field.Names[0].Name,
									}
									// Extract description from comment if available
									if field.Doc != nil {
										perm.Description = strings.TrimSpace(field.Doc.Text())
									}
									// Look for group tag in field
									if field.Tag != nil {
										tag := field.Tag.Value
										if strings.Contains(tag, "group:") {
											parts := strings.Split(tag, "group:")
											if len(parts) > 1 {
												groupPart := parts[1]
												endQuote := strings.Index(groupPart, "\"")
												if endQuote > 0 {
													perm.Group = groupPart[:endQuote]
												}
											}
										}
									}
									module.Permissions = append(module.Permissions, perm)
								}
							}
						}
					}
				}

				// Find Permissions variable
				if valueSpec, ok := n.(*ast.ValueSpec); ok {
					if len(valueSpec.Names) > 0 && valueSpec.Names[0].Name == "Permissions" {
						if compLit, ok := valueSpec.Values[0].(*ast.CompositeLit); ok {
							for _, elt := range compLit.Elts {
								if kv, ok := elt.(*ast.KeyValueExpr); ok {
									if key, ok := kv.Key.(*ast.Ident); ok {
										for i, perm := range module.Permissions {
											if perm.Name == key.Name {
												if basicLit, ok := kv.Value.(*ast.BasicLit); ok {
													module.Permissions[i].Value = strings.Trim(basicLit.Value, "\"")
												}
											}
										}
										// Find the Key field to set module key
										if key.Name == "Key" {
											if basicLit, ok := kv.Value.(*ast.BasicLit); ok {
												module.Key = strings.Trim(basicLit.Value, "\"")
											}
										}
									}
								}
							}
						}
					}
				}

				return true
			})

			// If we found permissions, add to modules
			if len(module.Permissions) > 0 && module.Key != "" {
				modules = append(modules, module)
			}
		}
		return nil
	})

	return modules, err
}

// generatePermissions generates the permissions file
func generatePermissions(modules []PermissionModule, outputFile string) error {
	// Create template for permissions
	tmpl := template.Must(template.New("permissions").Parse(`// Code generated by permgen; DO NOT EDIT.
package permissions

import (
	"github.com/PhantomX7/dhamma/entity"
)

const PermissionTypeApi = "API"
const PermissionTypeWeb = "WEB"

// ApiPermissions contains all API permissions generated from module definitions
var ApiPermissions = []entity.Permission{
	{{- range $module := . }}
	{{- range $perm := $module.Permissions }}
	{{- if ne $perm.Name "Key" }}
	{
		Name:             "{{ $module.Key }} - {{ $perm.Value }}",
		Object:           "{{ $module.Key }}",
		Action:           "{{ $perm.Value }}",
		Description:      "{{ or $perm.Description (printf "%s %s route" $module.Key $perm.Value) }}",
		Type:             PermissionTypeApi,
		IsDomainSpecific: false,
	},
	{{- end }}
	{{- end }}
	{{- end }}
}

// GetAllPermissionCodes returns all permission codes
func GetAllPermissionCodes() []string {
	codes := make([]string, len(ApiPermissions))
	for i, p := range ApiPermissions {
		codes[i] = p.Object + "/" + p.Action
	}
	return codes
}
`))

	// Create output file
	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	// Execute template
	return tmpl.Execute(f, modules)
}